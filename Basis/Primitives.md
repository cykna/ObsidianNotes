In general programming, we will have the so called primitives, that are the closest abstraction made from [Bytes](./Bytes.md) possible. These primitives can be a [Buffer](./Buffer.md), Numbers, Boolean, etc.
# Boolean
Starting with boolean, which are the easier ones. The term Boolean is a homage to the British Mathematician George Boole, which have invented the area of boolean algebra. A boolean is referred to something which value is True or False. Which is exactly how bits work. 
On Boolean algebra, and in programming in general, we have operations such as AND, OR and NOT, to determine the values of some boolean. In programming these operators are referred as &&, || and ! respectively, so this will talk about them as these operators.
In C, a boolean can be interpreted as anything that is not 0, so a value 5 is understood as true in a `if(5){...}` one of the reasons is that it contains a bit which value is 1 inside (5 in binary = 101). This might not be true for other languages such as Rust, where the type of the value matters and then, wont compile on a type mismatch, even though the logic is right.
When using multiple boolean's we will end up needing some boolean algebra to do so, thus, relying on the AND, OR and NOT operators. 
There's one thing so called truth table, that is worth mention, but won't be discussed here.
Let's say you get 2 boolean's, A and B, and you want that something happens when both are true, this can be made using A && B, which will look if both are true, if so, the resultant boolean is true, otherwise, it's false. With 'otherwise' i mean that if A or B are false, the return will be false. And on this phrase we already have another application. We know that `Let R = A && B` will be True when A and B are true, if some of them is false, it's false, which then is the `||` operator.  To work with something that requires at least one of them, we can use it. Let's say i want to find people who have color blindness or are totally blind, for this we will apply the same logic as `||`operator.  So `Let R = A || B` will be true when A is true, or B is true, or both.
Let's say we want to make something when Both are NOT true, we will end up using `!`, the NOT on programming will flip the value of a boolean. If some is True, !True will be false, if some is False, !False will be true. If i want do something when both are not true, we can do `Let R = !A && !B`. These are the basic usages, if you want something more in depth of boolean, you can look up for the wikipedia at [here](https://en.wikipedia.org/wiki/Boolean_algebra).
By default, in languages a boolean may have 1 byte of memory due to everything working at bytes scale and not bit.
# Integers
We also have numbers on programming, for sure, you might have already played with them. One integer can have any size in bits, an `int` in C has 4 bytes, then 32 bits. Due to this, the numbers have limits, and the way they're interpreted by the [CPU](../Concepts/CPU) determines these. 
In general we will have Signed and Unsigned numbers. Where Signed numbers will use a bit to determine their signal, while the Unsigned ones won't, thus, cannot be negative. For example, let's say an i8 and u8 in rust, both are 1 byte, but their representation is different:

u8 -> 1 Byte fully for data
i8 -> Highest Significant Bit for Signal, rest for data.

The same logic for any other type of number as long as it is a Integer. So a u64 and a i64 will have the same amount of bits, but u64 uses them all for data, and i64 uses the HSB for signal, and 63 for data. This leads an integer of type `uN` where N is a power of 2, >= 8, to have its bounds from `0..(2^N)-1` . When the same rule applies to a signed integer, this one will go from `-2^M..(2^M)-1`where M = N-1, since the highest bit is used for the signal. 